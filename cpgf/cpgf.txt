Todo:

2, Should support wide string in script binding.
1, metagen, should auto wrap bitfield with accessor functions.

1, In reflection, now finding base class is depending on global classes. Not fine. Should find base class in the most outter class recursively.
1, Metagen, needs to parse Doxygen document for annotation.
1, Support script override C++ functions. It's difficult. Adding interceptor in meta system is not enough.
1, GVariant passes rvalue reference as value, not efficient, should imporve.
4, Define meta data for C library?


Done:

1, In V8 binding, now when convert an object to V8, the constructor is always invoked. That's wrong. See function objectToV8, the line 
	Persistent<Object> self = Persistent<Object>::New(functionTemplate->GetFunction()->NewInstance());

1, GVariant should allow a variant of integer 0 to be casted to NULL pointer.
2, Support object pool in interface based api

Script binding refactoring:
2, Extrat the common logic in finding members to shared code.
1, Add user data for object, so class is different with object. This is important for supporting override C++ method from script.
2, All object, method, etc, user data, should know the class user data.

1, For method invoking in Lua, should use same way as V8 and Python. Current implementation may have problem in JIT?
3, Use shared pointer to hold GScriptBindingParam.


#include "cpgf/gapi.h"
#include "cpgf/gscopedptr.h"
#include <map>

typedef GSharedInterface<IScriptFunction> ScriptFunctionType;
typedef map<void *, ScriptFunctionType> MapType;
GScopedPointer<MapType> scriptFunctionMap;

void putScriptFunctionToMap(void * address, IScriptFunction * function)
{
	if(! scriptFunctionMap) {
		scriptFunctionMap.reset(new MapType);
	}
	(*scriptFunctionMap)[address].reset(function);
}

IScriptFunction * getScriptFunctionFromMap(void * address)
{
	if(! scriptFunctionMap) {
		return NULL;
	}
	IScriptFunction * function = (*scriptFunctionMap)[address].get();
	function->addReference();
	return function;
}

void clearScriptFunctionsInMap()
{
	if(scriptFunctionMap) {
		scriptFunctionMap->clear();
	}
}

